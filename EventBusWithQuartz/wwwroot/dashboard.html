<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Quartz.NET Dashboard</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css" integrity="sha512-2SwdPD6INVrV/lHTZbO2nodKhrnDdJK9/kg2XD1r9uGqPo1cUbujc+IYdlYdEErWNu69gVcYgdxlmVmzTWnetw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    body { background-color: #0f172a; }
    .pulse-dot { width:8px; height:8px; border-radius:50%; background:#10b981; box-shadow:0 0 0 0 rgba(16,185,129,.7); animation:pulse 2s infinite; }
    @keyframes pulse { 0% { box-shadow:0 0 0 0 rgba(16,185,129,.6);} 70% { box-shadow:0 0 0 6px rgba(16,185,129,0);} 100% { box-shadow:0 0 0 0 rgba(16,185,129,0);} }
    .animate-spin { animation: spin 1s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body class="min-h-screen text-slate-100 font-sans antialiased">
  <div id="root"></div>
  <script type="text/babel">
      const { useState, useEffect, useCallback, useRef } = React;
      const API_BASE = '/api/QuartzDashboard';
      const cx = (...c) => c.filter(Boolean).join(' ');

      const Card = ({ title, right, children, className }) => (
        <div className={cx('bg-slate-800/60 backdrop-blur border border-slate-700 rounded-xl shadow-sm shadow-slate-900/50 overflow-hidden', className)}>
          <div className="flex items-center justify-between px-5 py-3 border-b border-slate-700/70">
            <h2 className="flex items-center gap-2 text-sm font-semibold tracking-wide uppercase text-slate-300 leading-none">{title}</h2>
            {right && <div className="text-xs text-slate-400 leading-none">{right}</div>}
          </div>
          <div className="p-5 text-sm">{children}</div>
        </div>
      );

      const Stat = ({ label, value, iconClass, color='indigo' }) => (
        <div className="relative overflow-hidden rounded-xl bg-slate-800/60 border border-slate-700 backdrop-blur p-4 flex flex-col gap-1 shadow shadow-slate-900/40">
          <div className="flex items-center gap-2 text-slate-400 text-xs tracking-wide uppercase leading-none"><i className={cx(iconClass,'text-slate-400 text-sm fa-fw leading-none')}></i><span>{label}</span></div>
          <div className={cx('text-2xl font-bold bg-gradient-to-r bg-clip-text text-transparent leading-tight',
            color==='green' && 'from-emerald-300 to-emerald-500',
            color==='red' && 'from-rose-300 to-rose-500',
            color==='indigo' && 'from-indigo-300 to-indigo-500',
            color==='yellow' && 'from-amber-300 to-amber-500'
          )}>{value ?? '-'}</div>
        </div>
      );

      const Badge = ({ children, variant='default' }) => {
        const base = 'px-2 py-0.5 rounded text-xs font-medium leading-none';
        const map = { default:'bg-slate-700 text-slate-200', success:'bg-emerald-600/80 text-emerald-50', danger:'bg-rose-600/80 text-rose-50', warning:'bg-amber-500/90 text-amber-900', info:'bg-indigo-600/80 text-indigo-50', paused:'bg-rose-700/80 text-rose-50' };
        return <span className={cx(base, map[variant] || map.default)}>{children}</span>;
      };

      const Table = ({ columns, data, empty, rowKey='id', actions }) => (
        <div className="overflow-x-auto scrollbar-thin scrollbar-thumb-slate-600/50 scrollbar-track-slate-800/20 rounded-lg">
          <table className="min-w-full text-left text-xs">
            <thead>
              <tr className="bg-slate-700/60 text-slate-300">
                {columns.map(c => <th key={c.key} className="px-3 py-2 font-semibold whitespace-nowrap align-middle leading-none">{c.header}</th>)}
                {actions && <th className="px-3 py-2 font-semibold align-middle leading-none">Actions</th>}
              </tr>
            </thead>
            <tbody className="divide-y divide-slate-700/60">
              {data.length === 0 && (
                <tr><td colSpan={columns.length + (actions?1:0)} className="px-3 py-6 text-center text-slate-400">{empty}</td></tr>
              )}
              {data.map(row => (
                <tr key={row[rowKey] || JSON.stringify(row)} className="hover:bg-slate-700/40 transition">
                  {columns.map(c => (
                    <td key={c.key} className="px-3 py-2 align-middle whitespace-nowrap max-w-[260px] truncate" title={c.render ? '' : row[c.key]}>
                      {c.render ? c.render(row) : row[c.key] ?? '—'}
                    </td>
                  ))}
                  {actions && <td className="px-3 py-2 align-middle whitespace-nowrap">{actions(row)}</td>}
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      );

      const ActionButton = ({ onClick, children, variant='default', title, disabled }) => {
        const base = 'inline-flex h-7 min-w-7 items-center justify-center gap-1 px-2.5 rounded-md text-[11px] font-medium border shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-1 focus:ring-offset-slate-800 transition leading-none';
        const map = { default:'bg-slate-700 hover:bg-slate-600 border-slate-600 text-slate-100', primary:'bg-indigo-600 hover:bg-indigo-500 border-indigo-500 text-white', danger:'bg-rose-600 hover:bg-rose-500 border-rose-500 text-white', success:'bg-emerald-600 hover:bg-emerald-500 border-emerald-500 text-white' };
        const disabledCls = disabled ? 'opacity-50 pointer-events-none' : '';
        return <button title={title} disabled={disabled} onClick={onClick} className={cx(base, map[variant] || map.default, disabledCls)}>{children}</button>;
      };

      const Notification = ({ notice, onClear }) => {
        useEffect(() => { if (!notice) return; const t=setTimeout(onClear, notice.persist ? 0 : 4000); return () => clearTimeout(t); }, [notice]);
        if (!notice) return null;
        return (
          <div className={cx('fixed top-5 right-5 z-50 max-w-sm px-5 py-3 rounded-lg font-medium shadow-lg text-sm flex gap-3 backdrop-blur border',
            notice.type==='error' ? 'bg-rose-600/90 border-rose-400 text-rose-50' : notice.type==='warn' ? 'bg-amber-500/90 border-amber-400 text-amber-900' : 'bg-emerald-600/90 border-emerald-400 text-emerald-50')}
          >
            <div className='flex-1 space-y-1'>
              <div className='font-semibold tracking-wide text-xs uppercase opacity-80'>{notice.title || (notice.type==='error'?'Error':'Status')}</div>
              <div className='leading-snug'>{notice.message}</div>
              {notice.extra && <div className='text-[10px] opacity-70'>{notice.extra}</div>}
            </div>
            <button onClick={onClear} className="text-xs opacity-80 hover:opacity-100 leading-none"><i className="fa-solid fa-xmark fa-fw"></i></button>
          </div>
        );
      };

      function useFetch(initial) {
        const [data, setData] = useState(initial);
        const [loading, setLoading] = useState(false);
        const [error, setError] = useState(null);
        const run = useCallback(async (url) => {
          setLoading(true); setError(null);
          try {
            const res = await fetch(url);
            if (!res.ok) throw new Error(await res.text() || res.statusText);
            const json = await res.json();
            setData(json);
            return true;
          } catch (e) {
            setError(e.message);
            return false;
          } finally { setLoading(false); }
        }, []);
        return { data, setData, loading, error, run };
      }

      const SchedulerInfo = ({ info }) => {
        if (!info) return <div className="text-slate-400 text-sm">Loading...</div>;
        const items = [
          { label: 'Scheduler Name', value: info.schedulerName },
          { label: 'Instance ID', value: info.schedulerInstanceId },
          { label: 'Status', value: info.isStarted ? 'Started' : 'Stopped', badge: info.isStarted ? 'success':'danger' },
          { label: 'Standby Mode', value: info.inStandbyMode ? 'Yes' : 'No', badge: info.inStandbyMode ? 'warning':null },
          { label: 'Version', value: info.version },
          { label: 'Shutdown', value: info.isShutdown ? 'Yes' : 'No', badge: info.isShutdown ? 'danger':'success' }
        ];
        return (
          <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
            {items.map(i => (
              <div key={i.label} className="bg-slate-700/40 rounded-lg p-4 border border-slate-600/60 flex flex-col gap-1">
                <div className="text-[10px] tracking-wide font-semibold text-slate-400 uppercase leading-none">{i.label}</div>
                <div className="flex items-center gap-2 text-sm font-medium text-slate-100 leading-none">{i.badge ? <Badge variant={i.badge}>{i.value}</Badge> : <span>{i.value}</span>}</div>
              </div>
            ))}
          </div>
        );
      };

      const App = () => {
        const stats = useFetch({ totalJobs: 0, totalTriggers: 0, currentlyExecuting: 0 });
        const scheduler = useFetch(null);
        const jobs = useFetch([]);
        const triggers = useFetch([]);
        const executing = useFetch([]);

        const [lastUpdated, setLastUpdated] = useState(null);
        const [nextRefresh, setNextRefresh] = useState(null);
        const [notice, setNotice] = useState(null);
        const [busyAction, setBusyAction] = useState(false);
        const [refreshInterval, setRefreshInterval] = useState(() => parseInt(localStorage.getItem('qd_refresh_ms')) || 30000);
        const [batchLoading, setBatchLoading] = useState(false);
        const batchLoadingRef = useRef(false);

        const [failureCount, setFailureCount] = useState(0);
        const [pausedUntil, setPausedUntil] = useState(null);
        const baseBackoff = 5000;
        const maxBackoff = 60000;

        const inBackoff = pausedUntil && Date.now() < pausedUntil;
        const backoffRemaining = inBackoff ? Math.ceil((pausedUntil - Date.now()) / 1000) : 0;

        const resetBackoff = () => { setFailureCount(0); setPausedUntil(null); };

        const applyBackoff = (hadPartial) => {
          const nextFailure = failureCount + 1;
          setFailureCount(nextFailure);
          const delay = Math.min(baseBackoff * Math.pow(2, nextFailure - 1), maxBackoff);
          setPausedUntil(Date.now() + delay);
          setNotice({
            type: hadPartial ? 'warn' : 'error',
            title: hadPartial ? 'Partial Failure' : 'Batch Failure',
            message: hadPartial ? `Some data failed. Retrying in ${Math.round(delay/1000)}s.` : `All requests failed. Backoff ${Math.round(delay/1000)}s.`,
            extra: `Failures: ${nextFailure} · Backoff: ${Math.round(delay/1000)}s` ,
            persist: true
          });
        };

        // Helper to get next refresh time as Date
        const computeNextRefresh = useCallback(() => {
          if (inBackoff) return null;
          const now = Date.now();
          if (!lastUpdated) return new Date(now + refreshInterval);
          return new Date(lastUpdated.getTime() + refreshInterval);
        }, [lastUpdated, refreshInterval, inBackoff]);

        // Update nextRefresh after each refresh or interval change
        useEffect(() => {
          setNextRefresh(computeNextRefresh());
        }, [lastUpdated, refreshInterval, inBackoff, computeNextRefresh]);

        // Also update nextRefresh every second for countdown accuracy
        useEffect(() => {
          if (inBackoff) { setNextRefresh(null); return; }
          const id = setInterval(() => {
            setNextRefresh(computeNextRefresh());
          }, 1000);
          return () => clearInterval(id);
        }, [computeNextRefresh, inBackoff]);

        const loadAll = useCallback(async () => {
          if (batchLoadingRef.current || inBackoff) return;
          batchLoadingRef.current = true; setBatchLoading(true);
          try {
            const results = await Promise.all([
              stats.run(`${API_BASE}/statistics`),
              scheduler.run(`${API_BASE}/scheduler-info`),
              jobs.run(`${API_BASE}/jobs`),
              triggers.run(`${API_BASE}/triggers`),
              executing.run(`${API_BASE}/executing-jobs`)
            ]);
            const successes = results.filter(Boolean).length;
            if (successes === results.length) {
              setLastUpdated(new Date());
              if (failureCount > 0) setNotice({ type: 'success', title: 'Recovered', message: 'All data loaded.', extra: `Previous failures: ${failureCount}` });
              resetBackoff();
            } else if (successes === 0) {
              applyBackoff(false);
            } else {
              setLastUpdated(new Date());
              applyBackoff(true);
            }
          } finally {
            batchLoadingRef.current = false; setBatchLoading(false);
          }
        }, [inBackoff, failureCount]);

        useEffect(() => { loadAll(); }, [loadAll]);

        useEffect(() => {
          if (inBackoff) return;
          const id = setInterval(() => {
            if (!batchLoadingRef.current && !inBackoff) loadAll();
          }, refreshInterval);
          return () => clearInterval(id);
        }, [refreshInterval, inBackoff, loadAll]);

        useEffect(() => { localStorage.setItem('qd_refresh_ms', refreshInterval.toString()); }, [refreshInterval]);

        async function doJobAction(path, successMsg) {
          setBusyAction(true);
            try {
              const res = await fetch(path, { method: path.includes('delete-job') ? 'DELETE' : 'POST' });
              if (!res.ok) throw new Error(await res.text() || 'Request failed');
              setNotice({ type: 'success', message: successMsg });
              await loadAll();
            } catch (e) { setNotice({ type: 'error', message: e.message }); }
            finally { setBusyAction(false); }
        }

        const jobColumns = [
          { key: 'jobKey', header: 'Job Key' },
          { key: 'jobType', header: 'Job Type', render: r => <code className="text-xs text-indigo-300 leading-none">{r.jobType}</code> },
          { key: 'description', header: 'Description', render: r => r.description || <span className="text-slate-500 leading-none">N/A</span> },
          { key: 'durable', header: 'Durable', render: r => r.durable ? 'Yes' : 'No' },
          { key: 'triggers', header: 'Triggers', render: r => <Badge variant={r.triggers.length ? 'info' : 'default'}>{r.triggers.length}</Badge> }
        ];

        const triggerColumns = [
          { key: 'key', header: 'Trigger Key' },
          { key: 'jobKey', header: 'Job Key' },
          { key: 'state', header: 'State', render: r => { const v = r.state; const map = { Normal: 'info', Paused: 'paused' }; return <Badge variant={map[v] || 'default'}>{v}</Badge>; } },
          { key: 'nextFireTime', header: 'Next Fire' },
          { key: 'previousFireTime', header: 'Prev Fire' },
          { key: 'priority', header: 'Priority' }
        ];

        const execColumns = [
          { key: 'jobKey', header: 'Job Key' },
          { key: 'triggerKey', header: 'Trigger Key' },
          { key: 'fireTime', header: 'Fire Time' },
          { key: 'runTime', header: 'Run Time (ms)' },
          { key: 'recovering', header: 'Recovering', render: r => r.recovering ? 'Yes' : 'No' }
        ];

        function jobActions(row) {
          const [group, name] = row.jobKey.split('.')
          return (
            <div className="flex flex-wrap gap-1 items-center">
              <ActionButton variant='primary' disabled={busyAction} onClick={() => doJobAction(`${API_BASE}/trigger-job/${group}/${name}`, 'Job triggered')} title='Trigger'><i className="fa-solid fa-bolt fa-fw leading-none"></i></ActionButton>
              <ActionButton disabled={busyAction} onClick={() => doJobAction(`${API_BASE}/pause-job/${group}/${name}`, 'Job paused')} title='Pause'><i className="fa-solid fa-pause fa-fw leading-none"></i></ActionButton>
              <ActionButton variant='success' disabled={busyAction} onClick={() => doJobAction(`${API_BASE}/resume-job/${group}/${name}`, 'Job resumed')} title='Resume'><i className="fa-solid fa-play fa-fw leading-none"></i></ActionButton>
              <ActionButton variant='danger' disabled={busyAction} onClick={() => { if (confirm(`Delete job ${row.jobKey}?`)) doJobAction(`${API_BASE}/delete-job/${group}/${name}`, 'Job deleted'); }} title='Delete'><i className="fa-solid fa-trash fa-fw leading-none"></i></ActionButton>
            </div>
          );
        }

        return (
          <div className="max-w-7xl mx-auto px-4 py-8 space-y-8">
            <Notification notice={notice} onClear={() => setNotice(null)} />
            <header className="flex flex-col gap-4 md:flex-row md:items-center md:justify-between">
              <div className="flex items-start flex-col">
                <div className="flex items-center gap-2">
                  <span className="p-2 rounded-lg bg-indigo-600/20 border border-indigo-500/30 flex items-center justify-center h-10 w-10"><i className="fa-regular fa-clock text-indigo-300 text-lg leading-none"></i></span>
                  <h1 className="text-3xl font-bold bg-gradient-to-r from-indigo-300 via-emerald-300 to-cyan-300 bg-clip-text text-transparent leading-none">Quartz.NET Dashboard</h1>
                </div>
                <p className="text-slate-400 text-sm mt-2 ml-14 md:ml-0 leading-none">Monitor and manage scheduled jobs</p>
              </div>
              <div className="flex items-center gap-4 flex-wrap">
                <ActionButton onClick={() => window.open('/swagger', '_blank')} title='Open Swagger'><i className="fa-solid fa-book-bookmark fa-fw leading-none"></i><span className="leading-none">Swagger</span></ActionButton>
                <ActionButton variant='primary' onClick={() => loadAll()} title='Refresh Now' disabled={batchLoading || inBackoff}><i className={cx('fa-solid fa-rotate-right fa-fw leading-none', batchLoading && 'animate-spin')}></i><span className="leading-none">Refresh</span></ActionButton>
                <div className="flex flex-col gap-1 text-xs text-slate-400 leading-none">
                  <label className="flex items-center gap-2"> <i className="fa-solid fa-timer fa-fw"></i>
                    <span>Interval:</span>
                    <select
                      value={refreshInterval}
                      onChange={e => setRefreshInterval(parseInt(e.target.value))}
                      className="bg-slate-700 border border-slate-600 text-slate-200 text-[11px] rounded px-2 py-1 focus:outline-none focus:ring-2 focus:ring-indigo-500/50"
                      disabled={false}
                    >
      {/*disabled={batchLoading}*/}
                      <option value={1000}>1s</option>
                      <option value={2000}>2s</option>
                      <option value={5000}>5s</option>
                      <option value={10000}>10s</option>
                      <option value={30000}>30s</option>
                    </select>
                  </label>
                  {lastUpdated && <span className="leading-none">Updated: {lastUpdated.toLocaleTimeString()}</span>}
                </div>
                <div className="text-xs text-slate-400 flex flex-col leading-none min-w-[140px]">
                  <span className="flex items-center gap-2"><span className={cx('pulse-dot', (batchLoading||inBackoff) && '!bg-amber-400')}></span><span>{inBackoff ? `Backoff: ${backoffRemaining}s` : `Auto: ${refreshInterval/1000}s`}</span></span>
                  <span className="text-[10px] mt-0.5">{batchLoading ? 'Loading...' : inBackoff ? `Retry after ${backoffRemaining}s` : 'Idle'}</span>
                  {failureCount>0 && !inBackoff && <span className='text-[10px] text-amber-400 mt-0.5'>Failures: {failureCount}</span>}
                  {(!inBackoff && nextRefresh) && <span className="text-[10px] mt-0.5">Next refresh: {nextRefresh.toLocaleTimeString()}</span>}
                </div>
              </div>
            </header>

            <section className="grid gap-4 sm:grid-cols-2 lg:grid-cols-4">
              <Stat label='Total Jobs' value={stats.data.totalJobs} iconClass='fa-solid fa-box-archive' />
              <Stat label='Total Triggers' value={stats.data.totalTriggers} iconClass='fa-solid fa-clock' color='yellow' />
              <Stat label='Executing Jobs' value={stats.data.currentlyExecuting} iconClass='fa-solid fa-gears' color='green' />
              <Stat label='Status' value={scheduler.data?.isStarted ? 'Running' : 'Stopped'} iconClass='fa-solid fa-satellite-dish' color={scheduler.data?.isStarted ? 'green' : 'red'} />
            </section>

            <Card title={<span className='flex items-center gap-2 leading-none'><i className='fa-solid fa-satellite-dish fa-fw'></i> <span>Scheduler Information</span></span>} right={lastUpdated && <span className="leading-none">{lastUpdated.toLocaleTimeString()}</span>}>
              {scheduler.error && <div className='text-rose-400 text-sm mb-2 leading-none'>Error: {scheduler.error}</div>}
              <SchedulerInfo info={scheduler.data} />
            </Card>

            <Card title={<span className='flex items-center gap-2 leading-none'><i className='fa-solid fa-box-archive fa-fw'></i> <span>Jobs</span></span>} right={<span className="leading-none">{jobs.data.length} items</span>}>
              {jobs.error && <div className='text-rose-400 text-xs mb-2 leading-none'>Error: {jobs.error}</div>}
              <Table columns={jobColumns} data={jobs.data || []} empty='No jobs found.' actions={jobActions} />
            </Card>

            <div className="grid lg:grid-cols-2 gap-8">
              <Card title={<span className='flex items-center gap-2 leading-none'><i className='fa-solid fa-clock fa-fw'></i> <span>Triggers</span></span>} right={<span className="leading-none">{triggers.data.length} items</span>}>
                {triggers.error && <div className='text-rose-400 text-xs mb-2 leading-none'>Error: {triggers.error}</div>}
                <Table columns={triggerColumns} data={triggers.data || []} empty='No triggers found.' />
              </Card>
              <Card title={<span className='flex items-center gap-2 leading-none'><i className='fa-solid fa-gears fa-fw'></i> <span>Executing Jobs</span></span>} right={<span className="leading-none">{executing.data.length} running</span>}>
                {executing.error && <div className='text-rose-400 text-xs mb-2 leading.none'>Error: {executing.error}</div>}
                <Table columns={execColumns} data={executing.data || []} empty='No jobs currently executing.' />
              </Card>
            </div>

            <footer className="pt-4 border-t border-slate-700/70 text-xs text-slate-500 flex items-center justify-between leading-none">
              <span>Quartz.NET Dashboard</span>
              <span>Auto refresh: {refreshInterval/1000}s {inBackoff && `(backoff ${backoffRemaining}s)`}</span>
            </footer>
          </div>
        );
      };

      ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>